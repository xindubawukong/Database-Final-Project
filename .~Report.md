# 数据库大作业实验报告

## 成员

计65	尹一帆	2016011368

计65	丁相允	201601136

## 整体架构

参考斯坦福CS346的`Redbase`课程项目，我们的项目结构整体可以分为六大部分，文件系统、记录管理、索引管理、系统管理、查询语句以及最终面向用户的`Parser`。具体的模块间调用关系如下图所示：

![database](C:\Users\paolino\Desktop\database.png)

项目文件结构为每一个模块一个子目录，模块拥有自己的命名空间以防命名冲突，规范代码及开发流程。使用`Bazel`来管理项目的编译、测试、运行等操作。

## 模块详细设计以及主要接口

### 文件系统

助教提供了一个带有缓存管理的简易文件系统，但是就使用体验而言实在缺乏鲁棒性，存在诸多问题。

首先，哈希函数的映射设计的过于简单，仅仅只是文件ID与页号之和取模，很容易碰撞，不过这不影响正确性。

有问题的是，当我们打开过一个文件并读入某一页到缓存中再关闭后，打开另一文件的相同页号时，由于之前释放了文件ID的资源，很可能获取到相同的文件ID，然后访问到相同的缓存地址，读取到的内容并不清楚是本身之前的缓存还是其他文件的遗留物。

一个简易的处理方法是，使用`BufPageManager`管理打开的文件名与文件ID间的映射以及缓存index与文件名间的映射关系。打开文件时，判断文件名是否有对应ID，防止重复打开；关闭时，释放ID资源。缓存index则在文件访问到时，判断是否是对应的文件名，是则直接读取，否则替换并重新绑定文件名。并且增加了`Pin()`和`UnPin()`的接口，防止经常访问的页被替换。

所有打开、关闭等文件相关操作均在`BufPageManager`中实现，不直接访问`FileManager`。

### 索引管理

索引管理主要分为两小部分，`B+树`的实现，以及调用`B+树`实现加速查询的接口。

#### B+树

项目中，一页为8092Bytes，定义一个节点占有完整的一页，每页依次存储所有属性值、属性值对应的`RID`，然后依次是当前键值个数、总容量、左邻居节点页号以及右邻居节点页号，最后是节点自身的页号。节点类本身存放属性长度以及属性类型，并且不区分内部节点和叶子节点，只是内部节点的`RID`部分存子节点的页号，叶子节点的`RID`则存记录的实际位置。创建节点时，根据传的参数`attrLength`来决定可以存放的最大`RID`数量。

这棵`B+树`的属性值位置存放的是对应子节点的最大属性值，也就是说，节点内部以及整体都是升序组织的。

主要接口包括各种`Set/Get`函数：

```c++
int GetMaxKeys() const;
int GetNumKeys();
int SetNumKeys(int newNumKeys);
int GetLeft();
int SetLeft(int pageNum);
int GetRight();
int SetRight(int pageNum);
recordmanager::RID GetPageRID() const;
void SetPageRID(const recordmanager::RID&);
int GetPageNum() const;
void* LargestKey() const;
```

